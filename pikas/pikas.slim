initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	initializeTreeSeq();
	defaults = Dictionary(
		"seed", getSeed(),
		"SD", 93.20466, // sigma_D, dispersal distance
		"SX", 93.20466, // sigma_X, interaction distance for measuring local density
		"SM", 93.20466, // sigma_M, mate choice distance
		"K", 2.5e-4, // carrying capacity per unit area
		"LIFETIME", 3.25, // average life span
		"WIDTH", 16299, // width of the simulated area
		"HEIGHT", 16299, // height of the simulated area
		"BURNIN", 0, // number of ticks before recording
		"RUNTIME", 1400, // number of ticks to run the simulation for after burn-in
		"L", 2e9, // genome length
		"R", 1e-8, // recombination rate
		"MU", 0, // mutation rate
		"DISPERSAL_MAP_FILE", "./e_mat.png", 
		"ELEVATION_RANGE", c(7539, 13507) * 3.048e-4 // elevation range in ft from map legend -> converting to km
		);
	
	// Set up parameters with a user-defined function
	setupParams(defaults);
	
	defineConstant("FECUN", 1 / LIFETIME);
	defineConstant("RHO", FECUN/((1+FECUN) * K)); // constant in spatial competition function
	defineGlobal("PARAMS", defaults);

	setSeed(seed);
	
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L-1);
	initializeMutationRate(MU);
	initializeRecombinationRate(R);
	
	// elevation params
	defineConstant("dispersal_map", Image(DISPERSAL_MAP_FILE));
	defineGlobal("Elevation", dispersal_map.floatB * (ELEVATION_RANGE[1]-ELEVATION_RANGE[0]) + ELEVATION_RANGE[0]);
	defineGlobal("Temperature", -10 * Elevation + 37); // estimate temperature from elevation (Collados-Lara AJ et al., 2020)
	
	// spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SX * 3);
	i1.setInteractionFunction("n", 1, SX);
	
	// mate choice
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SM * 3);
	i2.setInteractionFunction("n", 1, SM);
}

1 first() {
	sim.addSubpop("p1", asInteger(K * WIDTH * HEIGHT));
	p1.setSpatialBounds(c(0, 0, WIDTH, HEIGHT));
	p1.defineSpatialMap("elevation", "xy", dispersal_map.floatB, interpolate=T, valueRange=c(0,1), colors=c("#0000FF", "#FFFFFF")); // this map is (only) for visualizing elevation in the GUI
	// random initial positions
	for (ind in p1.individuals) {
		ind.setSpatialPosition(p1.pointUniform());
		ind.tag = 0;
	}
	i1.evaluate(sim.subpopulations);
	
	community.rescheduleScriptBlock(s1, ticks=BURNIN + RUNTIME);
	
	// header info
	cat("gen" + " " + "stage" + " ");
	cat("pop_size" + " " + "births" + " ");
	cat("age" + " " + "density" + " ");
	catn("neighbor" + " " + "harm_neigh" + " " + "num_off" + " " + "time");
}

first() {
	// to be ready for mate choice
	i2.evaluate(p1);
}
reproduction() {
	// choose our nearest neighbor as a mate, within the max distance
	mate = i2.drawByStrength(individual, 1);
	if (mate.size()) {
		nOff = rpois(1, FECUN);
		offspring = subpop.addCrossed(individual, mate, count=nOff);
		// record number of offspring in the tag
		individual.tag = individual.tag + nOff;
		offspring.tag = 0;
	}
	return;
}

early() {
	// disperse offspring
	offspring = p1.subsetIndividuals(maxAge = 0);
	pos = offspring.spatialPosition;
	pos = p1.pointDeviated(offspring.size(), pos, "reprising", INF, "n", SD);
	offspring.setSpatialPosition(pos);
	// update temperature (0.016 / year; and assuming ticks are years, here)
	defineGlobal("Temperature", Temperature + 0.016); // increase global temperature
	
	// random noise: each year can be a 'hot' or 'cold' year 
	s = 2; // between-year std dev   *** NEED REFERENCE ***
	annual_stddev = rnorm(1,0,s);
	p1.defineSpatialMap("Temperature", "xy", Temperature+annual_stddev, interpolate=T, valueRange=c(0,1), colors=c("#FFFFFF", "#0000FF"));
	
	print("");
	print(c("sim cycle:", sim.cycle, "Temperature:", range(Temperature)));
	
	// calculate % habitable space
	// without stochasticity
	mydata = c(p1.individualCount, sum((Temperature)>(-5.0 + 6.830664) & (Temperature)<(28 - 4.97887)) / length(Temperature));
	// with stochasticity
	//mydata = c(p1.individualCount, sum((Temperature+annual_stddev)>(-5.0 + 6.830664) & (Temperature+annual_stddev)<(28 - 4.97887)) / length(Temperature));
	writeFile(OUTDIR + "/pika_simdata.txt", paste(mydata, sep='\t'), append=T);

}

early() {
	i1.evaluate(p1);
	inds = p1.individuals;
	competition = i1.localPopulationDensity(inds);
	
	// record strength of competition in the tagF
	inds.tagF = competition;
	inds.fitnessScaling = 1/(1 + RHO * competition);
	
	// kill indivs. outside optimal temperature range
	locations = inds.spatialPosition;      
	individual_temperatures = p1.spatialMapValue("Temperature", locations);
	// range from Beever et al, 2010; includes adjustment for winter cold
	// fitness = 0 if temperature is too low
	inds.fitnessScaling = inds.fitnessScaling * asFloat(individual_temperatures >= (-5.0 + 6.830664));
	// adjustment for summer heat; fitness = 0 if temperature too high
	inds.fitnessScaling = inds.fitnessScaling * asFloat(individual_temperatures <= (28 - 4.97887));
}



2: late() {
	// GUI COLORS
	//  green = many neighbors, few offspring so far
	//  red = many offspring so far, few neighbors
	//  yellow = many offspring so far, many neighbors
	max_n = max(1, max(p1.individuals.tag));
	max_f = max(0.01, max(p1.individuals.tagF));
	max_a = max(p1.individuals.age);
	for (ind in p1.individuals) {
		ind.color = rgb2color(c(ind.tag/max_n, ind.tagF/max_f, ind.age/max_a));
	}
}

s1 late() {
	sim.treeSeqOutput(OUTPATH, simplify=F);
	sim.simulationFinished();
}

function (void)setupParams(object<Dictionary>$ defaults)
{
	if (!exists("PARAMFILE")) defineConstant("PARAMFILE", "./params.json");
	if (!exists("OUTDIR")) defineConstant("OUTDIR", ".");
	defaults.addKeysAndValuesFrom(Dictionary("PARAMFILE", PARAMFILE, "OUTDIR", OUTDIR));
	
	if (fileExists(PARAMFILE)){
		local_defaults = Dictionary(readFile(PARAMFILE), sep="\n");
		defaults.addKeysAndValuesFrom(local_defaults);
		defaults.setValue("read_from_paramfile", PARAMFILE);
	}
	
	defaults.setValue("OUTBASE", OUTDIR + "/out_" +	defaults.getValue("seed"));
	defaults.setValue("OUTPATH", defaults.getValue("OUTBASE") + ".trees");
	
	for (k in defaults.allKeys) {
		if (!exists(k)) {
			defineConstant(k, defaults.getValue(k));
		}
		else {
			defaults.setValue(k, executeLambda(paste(c(k, ";"), sep='')));
		}
	}
	
	// print out default values
	catn("===========================");
	catn("Model constants: " + defaults.serialize());
	catn("===========================");

}